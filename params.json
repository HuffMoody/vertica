{"name":"Vertica","tagline":"Ruby adapter for Vertica databases","body":"# Vertica\r\n\r\nVertica is a pure Ruby library for connecting to Vertica databases. You can learn more\r\nabout Vertica at http://www.vertica.com.\r\n\r\n- Connecting, including over SSL\r\n- Executing queries, with results as streaming rows or buffered resultsets.\r\n- \"COPY table FROM STDIN\" statement to load data. \r\n- Tested against Ruby 1.9 and 2.0, and Vertica version 6.0 and 6.1.\r\n- The library is thread-safe as of version 0.11. However, you can only run one \r\n  statement at the time per connection, because the protocol is stateful.\r\n\r\n\r\n## Installation\r\n\r\n    $ gem install vertica\r\n\r\nOr add it to your Gemfile:\r\n\r\n    gem 'vertica'\r\n    # gem 'vertica', git: 'git://github.com/sprsquish/vertica.git' # HEAD version\r\n\r\n### Compatiblity\r\n\r\n- Ruby 1.8 is no longer supported, but version 0.9.x should still support it.\r\n- Vertica versions 4.1, 5.0, and 5.1 worked with at some point with this gem, but\r\n  compatibility is no longer tested. It probably still works as the protocol hasn't \r\n  changed.\r\n\r\n\r\n## Usage\r\n\r\n### Connecting\r\n\r\nThe <code>Vertica.connect</code> methods takes a connection parameter hash and returns a \r\nconnection object. For most options, the gem will use a default value if no value is provided.\r\n\r\n    connection = Vertica.connect({\r\n      :host     => 'db_server',\r\n      :user     => 'user',\r\n      :password => 'password',\r\n      # :ssl         => false, # use SSL for the connection\r\n      # :port        => 5433,  # default Vertica port: 5433\r\n      # :database    => 'db',  # there is only one database\r\n      # :role        => nil,   # the (additional) role(s) to enable for the user.\r\n      # :search_path => nil,   # default: <user>,public,v_catalog\r\n      # :row_style   => :hash  # can also be :array (see below)\r\n    })\r\n    \r\nTo close the connection when you're done with it, run <code>connection.close</code>.\r\n\r\n### Querying with unbuffered result as streaming rows\r\n\r\nYou can run simple queries using the <code>query</code> method, either in buffered and \r\nunbuffered mode. For large result sets, you probably do not want to use buffered results.\r\n\r\nGet all the result rows without buffering by providing a block:\r\n\r\n    connection.query(\"SELECT id, name FROM my_table\") do |row|\r\n      puts row # => {:id => 123, :name => \"Jim Bob\"}\r\n    end\r\n\r\nNote: you can only use the connection for one query at the time. If you try to run another \r\nquery when the connection is still busy delivering the results of a previous query, a\r\n`Vertica::Error::SynchronizeError` will be raised. Use buffered resultsets to prevent this\r\nproblem.\r\n\r\nStore the result of the query method as a variable to get a buffered resultset:\r\n\r\n    result = connection.query(\"SELECT id, name FROM my_table\")\r\n    connection.close\r\n    \r\n    result.rows # => [{:id => 123, :name => \"Jim Bob\"}, {:id => 456, :name => \"Joe Jack\"}]\r\n    result.row_count # => 2\r\n    \r\n    result.each do |row|\r\n      puts row # => {:id => 123, :name => \"Jim Bob\"}\r\n    end\r\n\r\n### Row format\r\n\r\nBy default, rows are returned as hashes, using symbols for the column names. Rows can also \r\nbe returned as arrays by providing a row_style:\r\n\r\n    connection.query(\"SELECT id, name FROM my_table\", :row_style => :array) do |row|\r\n      puts row # => [123, \"Jim Bob\"]\r\n    end\r\n    \r\nBy adding <code>:row_style => :array</code> to the connection hash, all results will be \r\nreturned as array.\r\n\r\n### Loading data using COPY\r\n\r\nUsing the COPY statement, you can load arbitrary data from your ruby script.\r\n\r\n    connection.copy(\"COPY table FROM STDIN ...\") do |stdin|\r\n      File.open('data.tsv', 'r') do |f|\r\n        begin \r\n          stdin << f.gets\r\n        end until f.eof?\r\n      end\r\n    end\r\n\r\nYou can also provide a filename or an IO object:\r\n\r\n    connection.copy(\"COPY table FROM STDIN ...\", \"data.csv\")\r\n    connection.copy(\"COPY table FROM STDIN ...\", io)\r\n\r\n\r\n## About\r\n\r\nThis package is MIT licensed. See the LICENSE file for more information.\r\n\r\n### Development\r\n\r\nThis project comes with a test suite. The unit tests in <tt>/test/unit</tt> do not need a database\r\nconnection to run, the functional tests in <tt>/test/functional</tt> do need a working\r\ndatabase connection. You can specify the connection parameters by copying the file\r\n<tt>/test/connection.yml.example</tt> to <tt>/test/connection.yml</tt> and filling out the \r\nnecessary fields. \r\n\r\nNote that the test suite requires write access to the default schema of the provided connection, \r\nalthough it tries to be as little invasive as possible: all tables it creates (and drops) are \r\nprefixed with <tt>test_ruby_vertica_</tt>.\r\n\r\n### TODO\r\n\r\n * Asynchronous / EventMachine version\r\n\r\n### Authors\r\n\r\n * [Matt Bauer](https://github.com/mattbauer) all the hard work\r\n * [Jeff Smick](https://github.com/sprsquish) current maintainer\r\n * [Willem van Bergen](https://github.com/wvanbergen) contributor\r\n * [Camilo Lopez](https://github.com/camilo) contributor\r\n * [Erik Selin](https://github.com/tyro89) contributor\r\n\r\n### See also\r\n\r\n* [Documentation](http://www.rubydoc.info/gems/vertica/frames) API documentation.\r\n* [sequel-vertica](https://github.com/camilo/sequel-vertica) Sequel integration.\r\n* [newrelic-vertica](https://github.com/wvanbergen/newrelic-vertica) NewRelic monitoring of queries.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}